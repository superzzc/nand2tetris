# chap7
1. constant 段处理方式
虚拟的，不占用目标平台上的物理存储。
vm实现通过简单提供常数i来处理任何vm对<constant i>的访问

2. SP初始化
这里假设已经完成了stack的初始化，直接使用
vm测试脚本中从RAM[256]开始

3. True/False的规范
-1(0xFFFF)表示true
0(0x0000)表示false

4. 避免翻译出的汇编中出现标签重复定义
定义标签的时候加点料
@{op}.{CodeWriter.label_count}
 ({op}.{CodeWriter.label_count})
 变量也是同样的道理

 5. 留意temp段的处理，基地址就是5，而非RAM[5]。pointer段同理。
 和local this that arg段不同

6. static段的处理
根据定义，static段在文件内共享，转换到汇编层面，就是要在同一个文件内，可以访问到同一个ram[N]
通过@filename.index的方式定义变量
push static 3 => @filename.index D=M

#chap 8
1. 將call時初始化function中k個local变量为0的任务提前到定义function的时候
处理call的时候留意避免重复压入

2. 翻译return的时候，SP = arg+1
留意栈顶SP位置，因为arg[0]新增了result

3. Sys.init引导程序必须确保位于汇编文件的开头
放在Codewriter实例初始化阶段完成

4. return addr的确定
由于hack体系中每条命令宽度固定为1个字，return addr = 当前call命令地址+1
call命令地址在asm汇编阶段才能确定。幸好我们不需要获得确切的PC，只需要在合适的位置生成标签来代替就好。
在vm层面，标签位置如下,转换到汇编层面，就是紧跟着call汇编命令末尾
call f N
(label)  <---- return addr
next command

5. call f n的语义
在n个参数被压入栈后调用函数f() 。换句话说，参数的压入是有
调用者在call之前自行处理的，不放在call f n的实现内。call f N
只需要设置正确的ARG指针即可

6. call f 0调用没有传递参数的时候，arg段的处理?
正常处理，此时arg指向栈上存放return-address的单元。当然，函数内不应该有arg段的任何引用

7. 留意标准映射中的符号约定
funcName$label
函数内的label、goto、if-goto命令生成的label都应该使用f$b的形式
vm命令没有缩进概念，出现在function xxx声明后的都属于函数的作用域，直到碰到下一个function声明

8.return-address
每个函数调用时应该生成的唯一标号。
同一个函数是否生成相同的标签？ 不行，考虑统一函数多次调用的情况

9.实现return指令的时候，是否可以使用同一个临时变量保存返回地址？
可以。同一时刻只能处理一个return，返回后，变量中的return-address就没用了，可以覆盖。
不需要每次遇到return的时候都新分配一个临时变量
